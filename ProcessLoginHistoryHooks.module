<?php

/**
 * Hooks for Process Login History
 *
 * This module inserts hooks required by Process Login History module and
 * handles saving data to related database table. Separated from main module
 * to keep ProcessWire from autoloading as much unnecessary code as possible.
 * 
 * For detailed information, installation instructions etc. see README.md.
 *
 * @copyright Copyright (c) 2012, Teppo Koivula
 *
 * ProcessWire 2.x 
 * Copyright (C) 2012 by Ryan Cramer 
 * Licensed under GNU/GPL v2, see LICENSE.TXT
 * 
 * http://processwire.com
 *
 */
 
class ProcessLoginHistoryHooks extends WireData implements Module, ConfigurableModule {

    /**
     * Return information about this module (required)
     *
     * @return array
     */
    public static function getModuleInfo() {
        return array(
            'title' => 'Login History Hooks',
            'summary' => 'Hooks required by Process Login History for collecting data',
            'href' => 'http://modules.processwire.com/modules/process-login-history/',
            'author' => 'Teppo Koivula',
            'version' => 100,
            'singular' => true,
            'autoload' => true,
            'requires' => 'ProcessLoginHistory'
        ); 
    }

    /**
     * Name of database table used by this module
     *
     */
    const TABLE_NAME = 'process_login_history';

    /**
     * Module configuration
     *
     * @param array $data
     * @return InputfieldWrapper
     */
    static public function getModuleConfigInputfields(array $data) {

        // this is a container for fields, basically like a fieldset
        $fields = new InputfieldWrapper();

        // since this is a static function, we can't use $this->modules, so get them from the global wire() function
        $modules = wire('modules');

        // should we log login attempts for nonexistent users?
        $field = $modules->get("InputfieldCheckbox");
        $field->name = "log_nonexistent_users";
        $field->label = "Log nonexistent users";
        $field->description = "If this option is selected, attempts to log in as nonexistent users will be logged.";
        if (isset($data['log_nonexistent_users'])) $field->checked = "checked";
        $fields->add($field);

        // for how long should login history be retained?
        $field = $modules->get("InputfieldSelect");
        $field->name = "history_max_age";
        $field->label = "History max age";
        $field->description = "How long should we retain login history?";
        if ($modules->isInstalled("LazyCron")) {
            $field->addOption('1 WEEK', '1 week');
            $field->addOption('2 WEEK', '2 weeks');
            $field->addOption('1 MONTH', '1 month');
            $field->addOption('2 MONTH', '2 months');
            $field->addOption('3 MONTH', '3 months');
            $field->addOption('6 MONTH', '6 months');
            $field->addOption('1 YEAR', '1 year');
            $field->notes = "Leave empty to disable automatic cleanup.";
        } else {
            $field->notes = "Automatic cleanup requires LazyCron module, which isn't currently installed.";
        }
        if (isset($data['history_max_age'])) $field->value = $data['history_max_age'];
        $fields->add($field);

        return $fields;
    }

    /**
     * Initialization function
     *
     * This function attachs hooks required by Process Login History.
     *
     */
    public function init() {

        // remove expired login history rows daily
        $this->addHook("LazyCron::everyDay", $this, 'cleanup');

        // hook after login to save login info into db 
        $this->addHookAfter('Session::login', $this, 'hookLogin');

        // hook after ProcessLogin::buildLoginForm to add useful extra fields
        $this->addHookAfter('ProcessLogin::buildLoginForm', $this, 'hookBuildLoginForm');

        // hook after ProcessController::execute to include a JavaScript file (admin only)
        $this->addHookAfter('ProcessController::execute', $this, 'hookExecute');

        // hook after ProcessPageEdit::execute to add latest login row to user profile (admin only)
        $this->addHookAfter('ProcessPageEdit::execute', $this, 'hookProcessPageEditExecute');

    }

    /**
     * Delete data older than max age defined in module settings
     *
     */
    public function cleanup() {

        if (!$this->history_max_age) return;

        $interval = $this->db->escape_string($this->history_max_age);
        $sql = "DELETE FROM " . self::TABLE_NAME . " WHERE login_timestamp < DATE_SUB(NOW(), INTERVAL $interval)";
        $this->db->query($sql);

    }

    /**
     * Executed when user has attempted to login
     *
     * This is used for saving login attempts to database table.
     *
     * @param HookEvent $event
     */
    public function hookLogin(HookEvent $event) {

        // default values
        $user_agent = $this->db->escape_string($_SERVER['HTTP_USER_AGENT']);
        $user_agent_features = array();
        $login_was_successful = 0;
        $user_id = 0;
        $user = null;

        // fetch and filter username from event arguments (using htmlentities() instead of
        // $sanitizer->pageName() to allow keeping track of broken / strange input values)
        $username = $this->db->escape_string(htmlentities($event->arguments[0]));

        // try to get user matching given username
        if (strtolower($username) == $this->sanitizer->pageName($username)) {
            $user = $this->users->get($username);
            if ($user->id) {
                $user_id = $user->id;
                if ($event->return) $login_was_successful = 1;
            }
        }
        if (!$user->id && !$this->log_nonexistent_users) return;

        // user agent features
        if (isset($_POST['flash'])) $user_agent_features['flash'] = 1;
        if (isset($_POST['javascript'])) $user_agent_features['javascript'] = 1;
        if (isset($_POST['screen'])) $user_agent_features['screen'] = $_POST['screen'];
        if (isset($_POST['window'])) $user_agent_features['window'] = $_POST['window'];
        if (count($user_agent_features)) {
            foreach ($user_agent_features as &$feature) {
                $feature = wire()->sanitizer->text(str_replace("'", "", $feature));
            }
            $user_agent_features = json_encode($user_agent_features);
        } else {
            $user_agent_features = null;
        }

        // insert new row into database
        $sql_fields = "user_id, username, login_was_successful, user_agent, user_agent_features";
        $sql_values = "$user_id, '$username', $login_was_successful, '$user_agent', '$user_agent_features'";
        $sql = "INSERT INTO " . self::TABLE_NAME . " ($sql_fields) VALUES ($sql_values)";
        $this->db->query($sql);

    }
    
    /**
     * This function is executed after login form markup has been created
     *
     * Used for injecting custom JavaScript file to page, which in turn adds
     * useful extra fields to the form.
     *
     * @param HookEvent $event
     */
    public function hookBuildLoginForm(HookEvent $event) {
        $this->config->scripts->add($this->config->urls->ProcessLoginHistory."js/login.js"); 
    }

    /**
     * This function is executed before page markup has been created
     *
     * Used for injecting custom JavaScript file to admin page. This file
     * contains mostly UI level additions.
     *
     * @param HookEvent $event
     */
    public function hookExecute(HookEvent $event) {
        if ($this->page->process !== "ProcessLoginHistory") return;
        $this->config->scripts->add($this->config->urls->ProcessLoginHistory."js/script.js"); 
    }

    /**
     * Function executed after Execute method of Process Page Edit
     *
     * The purpose of this is to add simplified version of login history
     * and links to full data of that particular user to user edit view.
     *
     * @param HookEvent $event
     */
    public function hookProcessPageEditExecute(HookEvent $event) {

        // this only applies to user edit view (admin)
        if ($event->object->page->process != "ProcessUser") return;

        // make sure that current user has view permission to login history page
        $login_history_id = $this->modules->getModuleID("ProcessLoginHistory");
        $login_history_page = $this->pages->get("template=admin, process=$login_history_id");
        if (!$this->user->hasPermission('view', $login_history_page)) return;
        
        // get (and validate) user object based on get param "id"
        $user = $this->users->get((int) $this->input->get->id);
        if (!$user->id) return;
        
        // get latest login attempts (return if no rows are found)
        $sql = "SELECT id, login_timestamp, login_was_successful 
                FROM " . self::TABLE_NAME . " 
                WHERE user_id = {$user->id} 
                ORDER BY login_timestamp DESC
                LIMIT 3";
        $result = $this->db->query($sql);
        if (!$result->num_rows) return;

        // get config data from main module (for uniform date formatting)
        $config = $this->wire->modules->getModuleConfigData("ProcessLoginHistory");

        $markup = "";
        while ($row = $result->fetch_assoc()) {
            
            $login_date = date($config['date_format'], strtotime($row['login_timestamp']));
            
            // make sure that currently used PHP version has DateTime implemented
            if (version_compare(PHP_VERSION, '5.3.0') >= 0) {
                $date_diff = date_diff(date_create(), date_create($login_date));
                if ($date_diff->format('%a') < 1) {
                    // less than a day since this login attempt
                    $date_diff = $date_diff->format('%h');
                    if ($date_diff < 1) $date_diff = __("less than an hour ago");
                    else $date_diff = sprintf(_n("one hour ago", "%d hours ago", $date_diff), $date_diff);
                } else {
                    // one or more days since this login attempt
                    $date_diff = $date_diff->format('%a');
                    $date_diff = sprintf(_n("one day ago", "%d days ago", $date_diff), $date_diff);
                }
                $date_diff = ", " . $date_diff;
            } else {
                // calculating date differences tends to get messy and there's no
                // real need to offer alternative solution for older PHP versions
                $date_diff = "";
            }
            
            // was login attempt succesful?
            $status = __("unsuccessful attempt");
            if ($row['login_was_successful']) $status = __("successful attempt");

            // markup for this particular login history row
            $more = "<a href='{$login_history_page->url}?id={$row['id']}'>" . __("more") . " &raquo;</a>";
            $markup .= "<li>$login_date <em>($status$date_diff)</em> $more</li>";
            
        }
        
        // put together final markup for login history
        $login_info = "<div class='user-login-history'>"
                    . "<ul>$markup</ul>"
                    . "<p><a href='{$login_history_page->url}?username={$user->name}'>"
                    . __("View entire login history for this user")
                    . " &raquo;</a></p>"
                    . "</div>";
        
        // load main modules styles and prepend created login history markup to event return value
        $this->config->styles->add($this->config->urls->ProcessLoginHistory."ProcessLoginHistory.css"); 
        $event->return = $login_info . $event->return;
        
    }

}