<?php

/**
 * Process Login History
 *
 * This module keeps track of login attempts to your site, both successful and
 * unsuccessful (tracking unsuccesful logins is off by default) in order to offer
 * better understanding about users' activity and environments they use / favor;
 * browsers, browser features such as Flash / JavaScript, devices, screen and
 * window sizes.
 *
 * For detailed information, installation instructions etc. see README.md.
 *
 * @copyright Copyright (c) 2012, Teppo Koivula
 *
 * ProcessWire 2.x 
 * Copyright (C) 2012 by Ryan Cramer 
 * Licensed under GNU/GPL v2, see LICENSE.TXT
 * 
 * http://processwire.com
 *
 */
 
class ProcessLoginHistory extends Process implements ConfigurableModule {
    
    /**
     * Return information about this module (required)
     *
     * @return array
     */
    public static function getModuleInfo() {
        return array(
            'title' => 'Login History',
            'summary' => 'Keep track of site login history',
            'href' => 'http://modules.processwire.com/modules/process-login-history/',
            'author' => 'Teppo Koivula',
            'version' => 90,
            'singular' => true,
            'autoload' => false,
            'installs' => 'ProcessLoginHistoryHooks'
        ); 
    }
    
    /**
     * Default configuration for this module
     *
     * The point of putting this in it's own function is so that you don't have to specify
     * these defaults more than once.
     *
     * @return array
     */
    static public function getDefaultData() {
        return array(
            'row_limit' => 25,
            'date_format' => 'Y-m-d H:i:s'
        );
    }
    
    /**
     * Names of admin page and database table used by this module
     *
     */
    const PAGE_NAME = 'login-history';
    const TABLE_NAME = 'process_login_history';

    /**
     * Populate the default config data
     *
     * ProcessWire will automatically overwrite it with anything the user has specifically configured.
     * This is done in construct() rather than init() because ProcessWire populates config data after
     * construct(), but before init().
     *
     */
    public function __construct() {
        foreach(self::getDefaultData() as $key => $value) {
            $this->$key = $value;
        }
    }

    /**
     * Module configuration
     *
     * @param array $data
     * @return InputfieldWrapper
     */
    static public function getModuleConfigInputfields(array $data) {

        // this is a container for fields, basically like a fieldset
        $fields = new InputfieldWrapper();

        // since this is a static function, we can't use $this->modules, so get them from the global wire() function
        $modules = wire('modules');

        // merge default config settings (custom values overwrite defaults)
        $defaults = self::getDefaultData();
        $data = array_merge($defaults, $data);

        // date format used
        $field = $modules->get("InputfieldText");
        $field->name = "date_format";
        $field->label = "Date Format";
        $field->notes = "See the [PHP date](http://www.php.net/manual/en/function.date.php) function reference for more information on how to customize this format.";
        $field->value = ($data['date_format']) ? $data['date_format'] : $defaults['date_format'];
        $field->size = 70;
        $fields->add($field);

        // number of results visible at once
        $field = $modules->get("InputfieldSelect");
        $field->name = "row_limit";
        $field->label = "Row Limit";
        $field->description = "Number of login history rows visible at once";
        $field->required = true;
        $field->addOptions(array(25 => '25', 50 => '50', 75 => '75', 100 => '100'));
        $field->value = $data['row_limit'];
        $fields->add($field);

        return $fields;
    }

    /**
     * Initialization function called before any execute functions
     *
     */
    public function init() {
        parent::init();
    }

    /**
     * Executed when a page with this Process assigned is accessed
      *
     * @return string
     */
    public function ___execute() {

        // setup admin data table for login history
        $table = $this->modules->get("MarkupAdminDataTable");
        $table->setEncodeEntities(false);
        $table->setClass('login-history');
        $table->headerRow(array(
                __('User'),
                __('When'),
                __('Successful attempt?'),
                '', // placeholder
                __('More')
            ));

        // variables required by pager
        $limit = $this->row_limit;
        $start = ($this->input->get->page) ? (int) ($this->input->get->page-1)*$limit : 0;
        $total = $this->db->query("SELECT count(*) FROM " . self::TABLE_NAME)->fetch_row();
        $total = $total[0];
        if ($start > $total) $start = $total-$limit;

        // should date formatting occur?
        $defaults = self::getDefaultData();
        $date_format = ($this->date_format != $defaults['date_format']) ? $this->date_format : null;

        // fetch login history from database
        $result = $this->db->query("SELECT * FROM " . self::TABLE_NAME . " ORDER BY login_timestamp DESC LIMIT $start, $limit");

        while($row = $result->fetch_assoc()) {

            // empty container
            $data = array();
            
            // escape values (just a precaution really)
            foreach ($row as $key => $value) {
                if ($key != "user_agent_features") $row[$key] = htmlentities($value);
            }

            // basic user information; if user_id is set user exists or at least existed at
            // the time of login attempt (still need to check if that's currently true though)
            if ($row['user_id']) {
                $user = $this->users->get($row['user_id']);
                if ($user->id) $data[$user->name] = $user->url;
                else $data[] = $row['username'] . " <em>(" . __("removed") . ")</em>";
            } else {
                $data[] = $row['username'] . " <em>(" . __("nonexistent") . ")</em>";
            }

            // timestamp (raw timestamp is hidden and only included to allow proper ordering with JavaScript)
            $date = ($date_format) ? date($date_format, strtotime($row['login_timestamp'])) : $row['login_timestamp'];
            $data[] = "<span>{$row['login_timestamp']}</span>$date";

            // status of login attempt
            if ($row['login_was_successful']) $data[] = __("Yes");
            else $data[] = "<em>" . __("No") . "</em>";

            // link for removing individual history row
            $data[] = "<a href='./delete/?id={$row['id']}' class='remove'>" . __("remove?") . "</a>";

            // environment and user agent
            if ($row['user_agent']) $data[] = $this->renderBrowserInfo($row['user_agent'], $row['user_agent_features']);
            else $data[] = __("No data available.");

            // add new table row
            $table->row($data);
            
        }

        // pager markup
        $pager_pages = ceil($total/$limit)+1;
        $pager_page = ($start/$limit)+1;
        $pager = "";
        if ($total > $limit) {
            $pager .= "<ul class='MarkupPagerNav MarkupPagerNavCustom'>";
            for ($i=1; $i<$pager_pages; ++$i) {
                $pager_here = ($pager_page == $i) ? " class='MarkupPagerNavOn'" : "";
                $pager .= "<li$pager_here><a href='./?page=$i'><span>$i</span></a></li>";
            }
            $pager .= "</ul>";
        }

        // UI translations
        $translations = "<div id='translations'>";
        $translations .= "<span data-term='more'>" . __("more") . "</span>";
        $translations .= "<span data-term='less'>" . __("less") . "</span>";
        $translations .= "<span data-term='are_you_sure'>" . __("Are you sure?") . "</span>";
        $translations .= "<span data-term='remove_failed'>" . __("Sorry, remove failed") . "</span>";
        $translations .= "</div>";

        // return admin data table markup, pager and translations
        return $table->render().$pager.$translations;

    }    

    /**
     * Executed when requesting removal of an individual row
      *
     * @return boolean
     */
    public function ___executeDelete() {

        if ((int) $this->input->get->id != $this->input->get->id) return false;

        $id = (int) $this->input->get->id;
        $sql = "DELETE FROM " . self::TABLE_NAME . " WHERE id = $id LIMIT 1";
        $this->db->query($sql);

        return true;

    }

    /**
     * Render human readable view of browser / platform information
     *
     * @param string $user_agent
     * @param string $user_agent_features
     * @return string
     */
    private function renderBrowserInfo($user_agent = null, $user_agent_features = null) {

        // user agent string is required
        if (!$user_agent) return false;

        // init vars
        $markup = "";
        $browser = $this->get_browser_alt($user_agent);
        $features = ($user_agent_features) ? json_decode($user_agent_features) : null;

        // basic information from user agent string
        $markup .= "<tr><th>" . __("Browser") . "</th><td>{$browser->browser} {$browser->version}</td></tr>";
        $markup .= "<tr><th>" . __("Platform") . "</th><td>{$browser->platform}</td></tr>";
        $markup .= "<tr id='device-type'><th>" . __("Device Type") . "</th><td>{$browser->device}</td></tr>";

        if ($features) {

            // note: since feature detection is implemented with javascript, these will not be available
            // without proper js support!

            // escape values (just a precaution)
            foreach ($features as &$feature) $feature = htmlentities($feature);

            // javascript support
            $markup .= "<tr><th>JavaScript</th><td>";
            if (isset($features->javascript) && $features->javascript) $markup .= __("Enabled");
            else $markup .= __("Disabled");
            $markup .= "</td></tr>";

            // flash support
            $markup .= "<tr><th>Flash</th><td>";
            if (isset($features->flash) && $features->flash) $markup .= __("Enabled");
            else $markup .= __("Disabled");
            $markup .= "</td></tr>";

            // screen size
            $markup .= "<tr><th>" . __("Screen") . "</th><td>";
            if (isset($features->screen) && $features->screen) $markup .= $features->screen;
            else $markup .= __("unidentified");
            $markup .= "</td></tr>";

            // window size
            $markup .= "<tr><th>" . __("Window") . "</th><td>";
            if (isset($features->window) && $features->window) $markup .= $features->window;
            else $markup .= __("unidentified");
            $markup .= "</td></tr>";

        } else {

            // javascript-dependent feature checking has failed
            $markup .= "<tr><th>JavaScript</th><td>" . __("Disabled") . "</td></tr>";

        }
        
        return "<table class='user-agent'>$markup</table>";

    }

    /**
     * Simplified replacement for PHP's native get_browser()
     *
     * PHP get_browser() depends on external browscap file and an ini directive
     * that cannot be set run-time. This is why we're introducing an alternative
     * method that provides the most rudimentary features without any extra fuss.
     *
     * @param string $user_agent
     * @return stdClass|null
     */
    private function get_browser_alt($user_agent = null) {

        if (!$user_agent) return null;

        // empty container object for browser info
        $b = new stdClass();
        $b->browser = __("unknown");
        $b->version = null;
        $b->majorver = 0;
        $b->minorver = 0;
        $b->revision = 0;
        $b->platform = __("unknown");
        $b->device = __("desktop");
        
        // very rough device type detection
        if (preg_match("/Android|webOS|iPhone|iPod|BlackBerry/i", $user_agent)) $b->device = __("mobile");
        else if (preg_match("/iPad|Tablet/i", $user_agent)) $b->device = __("tablet");

        // identify platform
        if (preg_match("/\(([a-zA-Z0-9\.;:\/\-_ ]+)\)/", $user_agent, $match)) {
            if (strstr($match[1], "Windows")) {
                $b->platform = "Windows";
            } else {
                $b->platform = strtok($match[1], ";");
                if (strstr($match[1], "Android")) {
                    $b->platform = (preg_match("/Android[ 0-9\.]*/", $match[1], $match)) ? $match[0] : "Android";
                }
            }
        }

        // identify version number (mostly for Safari and Opera)
        if (preg_match("/version\/([0-9.]*)/i", $user_agent, $match)) {
            $b->version = $match[1];
        }

        // identifiable browser strings
        $browsers = array(
            'firefox', 'msie', 'opera', 'chrome', 'safari', 'mozilla', 'seamonkey', 'konqueror', 'netscape',
            'gecko', 'navigator', 'mosaic', 'lynx', 'amaya', 'omniweb', 'avant', 'camino', 'flock', 'aol'
        );

        // identify current browser
        foreach($browsers as $browser) {
            if (preg_match("/([a-z]*?[ ]?$browser)[\/ ]?([0-9.]*)/i", $user_agent, $match)) {
                $b->browser = $match[1];
                if (!$b->version) $b->version = $match[2];
                @list($b->majorver, $b->minorver, $b->revision) = explode('.', $b->version);
                break;
            }
        }

        // special case: android browser reports itself as mobile safari
        if (strpos($b->platform, "Android") !== false && $match[1] == "Mobile Safari") {
            $b->browser = "Android Browser";
        }

        return $b;

    }

    /**
     * Called only when this module is installed
     *
     * Creates new page with this Process module assigned and new database
     * table for storing login history data.
     *
     */
    public function ___install() {

        // create database table this module requires
        $sql = "
        CREATE TABLE " . self::TABLE_NAME . " (
            id INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
            user_id INT(10) UNSIGNED NOT NULL DEFAULT 0,
            username VARCHAR(128) NOT NULL,
            user_agent VARCHAR(256) DEFAULT NULL,
            user_agent_features TEXT DEFAULT NULL,
            login_was_successful BOOLEAN DEFAULT 0,
            login_timestamp TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
        ) ENGINE = MYISAM;
        ";
        $this->db->query($sql);

        // tell the user that we've created new database table
        $this->message("Created Table: " . self::TABLE_NAME); 

        // create a page for this module
        $page = new Page();
        $page->template = 'admin';
        $page->name = self::PAGE_NAME; 
        $page->process = $this; 

        // insert page under setup at admin
        $page->parent = $this->pages->get($this->config->adminRootPageID)->child('name=setup');

        // make page title match module title
        $info = self::getModuleInfo();
        $page->title = $info['title'];

        // save the page
        $page->save();

        // tell user that we've created a new page
        $this->message("Created Page: {$page->path}"); 

    }

    /**
     * Called only when this module is uninstalled
     *
     * Removes page associated with this Process module and also drops related table.
     *
     */
    public function ___uninstall() {

        // find the page we installed, locating it by the process field (which has the module ID)
        // it would probably be sufficient just to locate by name, but this is just to be extra sure.
        $moduleID = $this->modules->getModuleID($this); 
        $page = $this->pages->get("template=admin, process=$moduleID, name=" . self::PAGE_NAME); 

        if($page->id) {
            // if we found the page, let the user know and delete it
            $this->message("Deleting Page: {$page->path}"); 
            $page->delete();
        }

        // if database table exists, drop it
        $this->message("Deleting Table: " . self::TABLE_NAME);
        $this->db->query("DROP TABLE IF EXISTS " . self::TABLE_NAME);

    }
    
}