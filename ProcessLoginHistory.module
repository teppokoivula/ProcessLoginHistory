<?php

/**
 * Process Login History
 *
 * This module keeps record of login attempts to your site, both succesful and
 * unsuccesful (tracking unsuccesful logins is off by default) in order to offer
 * better understanding about users' activity and environments they use / favor;
 * browsers, browser features such as Flash / JavaScript, devices, screen and
 * window sizes.
 *
 * For detailed information, installation instructions etc. see README.md file.
 *
 * @copyright Copyright (c) 2012, Teppo Koivula
 *
 * ProcessWire 2.x 
 * Copyright (C) 2012 by Ryan Cramer 
 * Licensed under GNU/GPL v2, see LICENSE.TXT
 * 
 * http://processwire.com
 *
 */
 
class ProcessLoginHistory extends Process {

    /**
     * Return information about this module (required)
     *
     * @return array
     */
    public static function getModuleInfo() {
        return array(
            'title' => 'Login History',
            'summary' => 'Keep track of site login history',
            'href' => 'http://modules.processwire.com/',
            'author' => 'Teppo Koivula',
            'version' => 80,
            'singular' => true,
            'autoload' => false,
            'installs' => 'ProcessLoginHistoryHooks'
        ); 
    }

    /**
     * Names of admin page and database table used by this module
     *
     */
    const PAGE_NAME = 'login-history';
    const TABLE_NAME = 'process_login_history';

    /**
     * Initialization function called before any execute functions
     *
     */
    public function init() {
        parent::init();
    }

    /**
     * Executed when a page with this Process assigned is accessed
      *
     * @return string
     */
    public function ___execute() {

        // setup admin data table for login history
        $table = $this->modules->get("MarkupAdminDataTable");
        $table->setEncodeEntities(false);
        $table->setClass('login-history');
        $table->headerRow(array(
                'User',
                'When',
                'Succesful attempt?',
                'More'
            ));

        // variables required by pager
        $limit = 25;
        $start = (wire()->input->get->page) ? (wire()->input->get->page-1)*$limit : 0;
        $total = $this->db->query("SELECT count(*) FROM " . self::TABLE_NAME)->fetch_row();
        $total = $total[0];
        if ($start > $total) $start = $total-$limit;

        // fetch login history from database
        $result = $this->db->query("SELECT * FROM " . self::TABLE_NAME . " ORDER BY login_timestamp DESC LIMIT $start, $limit");

        while($row = $result->fetch_assoc()) {

            // empty container
            $data = array();

            // basic user information; if user_id is set user exists or at least existed at
            // the time of login attempt (still need to check if that's currently true though)
            if ($row['user_id']) {
                $user = $this->users->get($row['user_id']);
                if ($user->id) $data[$user->name] = "../../access/users/edit/?id={$user->id}";
                else $data[] = $row['username'] . " <em>(removed)</em>";
            } else {
                $data[] = $row['username'] . " <em>(nonexistent)</em>";
            }

            // timestamp (first row is hidden and only included to allow proper ordering with JavaScript)
            $data[] = "<span>{$row['login_timestamp']}</span>" . $row['login_timestamp'];

            // status of login attempt
            $data[] = ($row['login_was_successful']) ? "Yes" : "<em>No</em>";

            // environment and user agent
            if ($row['user_agent']) {
                // init vars
                $markup = "";
                $browser = $this->get_browser_alt($row['user_agent']);
                $features = ($row['user_agent_features']) ? json_decode($row['user_agent_features']) : null;
                // basic information from user agent string
                $markup .= "<tr><th>Browser</th><td>{$browser->browser} {$browser->version}</td></tr>";
                $markup .= "<tr><th>Platform</th><td>{$browser->platform}</td></tr>";
                $markup .= "<tr id='device-type'><th>Device Type</th><td>{$browser->device}</td></tr>";
                if ($features) {
                    // more specific features; these depend on javascript support
                    $markup .= "<tr><th>JavaScript</th><td>" . ((isset($features->javascript)&&$features->javascript) ? "Enabled" : "Disabled") . "</td></tr>";
                    $markup .= "<tr><th>Flash</th><td>" . ((isset($features->flash)&&$features->flash) ? "Enabled" : "Disabled") . "</td></tr>";
                    $markup .= "<tr><th>Screen</th><td>" . ((isset($features->screen)&&$features->screen) ? $features->screen : "unidentified" ) . "</td></tr>";
                    $markup .= "<tr><th>Window</th><td>" . ((isset($features->window)&&$features->window) ? $features->window : "unidentified" ) . "</td></tr>";
                } else {
                    // javascript-dependent feature checking has failed
                    $markup .= "<tr><th>JavaScript</th><td>Disabled</td></tr>";
                }
                $data[] = "<table class='user-agent'>$markup</table>";
            } else {
                $data[] = "no data available";
            }

            // add new table row
            $table->row($data);
            
        }

        // pager markup
        $pager_pages = ceil($total/$limit)+1;
        $pager_page = ($start/$limit)+1;
        $pager = "";
        if ($total > $limit) {
            $pager .= "<ul class='MarkupPagerNav MarkupPagerNavCustom'>";
            for ($i=1; $i<$pager_pages; ++$i) {
                $pager_here = ($pager_page == $i) ? " class='MarkupPagerNavOn'" : "";
                $pager .= "<li$pager_here><a href='./?page=$i'><span>$i</span></a></li>";
            }
            $pager .= "</ul>";
        }

        // return admin data table markup and pager
        return $table->render().$pager;

    }    

    /**
     * Simplified replacement for PHP's native get_browser()
     *
     * PHP get_browser() depends on external browscap file and an ini directive
     * that cannot be set run-time. This is why we're introducing an alternative
     * method that provides the most rudimentary features without any extra fuss.
     *
     * @param string $user_agent
     * @return stdClass|null
     *
     */
    private function get_browser_alt($user_agent = null) {

        if (!$user_agent) return null;

        // empty container object
        $object = new stdClass();
        $object->browser = 'unknown';
        $object->version = null;
        $object->majorver = 0;
        $object->minorver = 0;
        $object->revision = 0;
        $object->platform = 'unknown';
        $object->device = 'desktop';
        
        // very rough device type detection
        if (preg_match("/Android|webOS|iPhone|iPod|BlackBerry/i", $user_agent)) $object->device = "mobile";
        else if (preg_match("/iPad/i", $user_agent)) $object->device = "tablet";

        // identify platform
        if (preg_match("/\(([a-zA-Z0-9\.\;\:\/\- ]+)\)/", $user_agent, $match)) {
	        if (strstr($match[1], "Windows")) {
		        $object->platform = "Windows";
	        } else {
		        $object->platform = str_replace(";", "", strtok($match[1], " "));
		        if ($object->platform == "Linux") {
			        if (strstr($match[1], "Android")) $object->platform = "Android";
		        }
	        }
        }

        // identify version number (mostly for Safari and Opera)
        if (preg_match("/version\/([0-9.]*)/i", $user_agent, $match)) {
            $object->version = $match[1];
        }

        // identifiable browser strings
        $browsers = array(
            'firefox', 'msie', 'opera', 'chrome', 'safari', 'mozilla', 'seamonkey', 'konqueror', 'netscape',
            'gecko', 'navigator', 'mosaic', 'lynx', 'amaya', 'omniweb', 'avant', 'camino', 'flock', 'aol'
        );

        // identify current browser
        foreach($browsers as $browser) {
            if (preg_match("/([a-z]*?[ ]?$browser)[\/ ]?([0-9.]*)/i", $user_agent, $match)) {
	            if ($object->platform == "Android" && $match[1] == "Mobile Safari") {
		            $object->browser = "Android Browser";
		            $object->version = null;
	            } else {
		            $object->browser = $match[1];
		            if (!$object->version) $object->version = $match[2];
		            @list($object->majorver, $object->minorver, $object->revision) = explode('.', $object->version);
	            }
                break;
            }
        }

        return $object;

    }

    /**
     * Called only when this module is installed
     *
     * Creates new page with this Process module assigned and new database
     * table for storing login history data.
     *
     */
    public function ___install() {

        // create database table this module requires
        $sql = "
        CREATE TABLE " . self::TABLE_NAME . " (
            id INT UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY,
            user_id INT(10) UNSIGNED NOT NULL DEFAULT 0,
            username VARCHAR(128) NOT NULL,
            user_agent VARCHAR(256) DEFAULT NULL,
            user_agent_features TEXT DEFAULT NULL,
            login_was_successful BOOLEAN DEFAULT 0,
            login_timestamp TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP
        ) ENGINE = MYISAM;
        ";
        $this->db->query($sql);

        // tell the user that we've created new database table
        $this->message("Created Table: " . self::TABLE_NAME); 

        // create a page for this module
        $page = new Page();
        $page->template = 'admin';
        $page->name = self::PAGE_NAME; 
        $page->process = $this; 

        // insert page under setup at admin
        $page->parent = $this->pages->get($this->config->adminRootPageID)->child('name=setup');

        // make page title match module title
        $info = self::getModuleInfo();
        $page->title = $info['title'];

        // save the page
        $page->save();

        // tell user that we've created a new page
        $this->message("Created Page: {$page->path}"); 

    }

    /**
     * Called only when this module is uninstalled
     *
     * Removes page associated with this Process module and also drops related table.
     *
     */
    public function ___uninstall() {

        // find the page we installed, locating it by the process field (which has the module ID)
        // it would probably be sufficient just to locate by name, but this is just to be extra sure.
        $moduleID = $this->modules->getModuleID($this); 
        $page = $this->pages->get("template=admin, process=$moduleID, name=" . self::PAGE_NAME); 

        if($page->id) {
            // if we found the page, let the user know and delete it
            $this->message("Deleting Page: {$page->path}"); 
            $page->delete();
        }

        // if database table exists, drop it
        $this->message("Deleting Table: " . self::TABLE_NAME);
        $this->db->query("DROP TABLE IF EXISTS " . self::TABLE_NAME);

    }
    
}